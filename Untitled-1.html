<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atomic Orbit Audio Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #f0f0f0;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 20px;
            width: 100%;
            max-width: 800px;
        }

        .visualization-container {
            width: 100%;
            aspect-ratio: 1;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        svg {
            width: 100%;
            height: 100%;
        }

        .control-panel {
            display: flex;
            gap: 16px;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #45a049;
        }

        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        .orbit {
            fill: none;
            stroke-opacity: 0.85;
            transition: stroke-width 0.3s ease;
        }

        .volume-ring {
            fill: none;
            stroke-opacity: 0.85;
            transition: stroke-width 0.3s ease;
        }

        .particle {
            transition: all 0.3s ease;
        }

        .rays line {
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="visualization-container">
            <svg viewBox="-200 -200 400 400" preserveAspectRatio="xMidYMid meet">
                <circle class="volume-ring" r="80" cx="0" cy="0" stroke-width="1" />
                <g class="visualization-group">
                    <circle class="center-particle particle" r="4" cx="0" cy="0" fill="black" />
                    <g class="rays"></g>
                    <g class="orbits"></g>
                </g>
            </svg>
        </div>
        <div class="control-panel">
            <button id="startBtn">開始錄音</button>
            <button id="stopBtn" disabled>停止錄音</button>
        </div>
    </div>

    <script>
        class AudioVisualizer {
            constructor() {
                this.initializeVariables();
                this.setupEventListeners();
                this.createVisualElements();
            }

            initializeVariables() {
                this.isRecording = false;
                this.animationFrameId = null;
                this.startTime = null;
                this.currentColor = 'rgb(0, 0, 0)';
                
                this.audioContext = null;
                this.analyser = null;
                this.mediaRecorder = null;
                this.source = null;

                this.rayRotation = 0;
                this.rayAmplitudes = [];
                this.rayPhases = [];

                this.startBtn = document.getElementById('startBtn');
                this.stopBtn = document.getElementById('stopBtn');
            }

            setupEventListeners() {
                this.startBtn.addEventListener('click', () => this.startRecording());
                this.stopBtn.addEventListener('click', () => this.stopRecording());
            }

            createVisualElements() {
                this.createRays();
                this.createOrbitGroups(3);
            }

            createRays() {
                const raysGroup = document.querySelector('.rays');
                const rayCount = 32;
                
                for (let i = 0; i < rayCount; i++) {
                    const angle = (i * 360) / rayCount;
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", "0");
                    line.setAttribute("y1", "-20");
                    line.setAttribute("x2", "0");
                    line.setAttribute("y2", "-40");
                    line.setAttribute("transform", `rotate(${angle})`);
                    line.setAttribute("stroke", "black");
                    line.setAttribute("stroke-width", "1");
                    line.setAttribute("data-base-length", "20");
                    this.rayAmplitudes[i] = Math.random() * 2 + 1;
                    this.rayPhases[i] = Math.random() * Math.PI * 2;
                    raysGroup.appendChild(line);
                }
            }

            createOrbitGroups(particleCount) {
                const orbitsGroup = document.querySelector('.orbits');
                orbitsGroup.innerHTML = '';

                const orbitConfigs = [
                    { rx: 160, ry: 100, speed: 0.3 },
                    { rx: 140, ry: 90, speed: -0.4 },
                    { rx: 120, ry: 80, speed: 0.5 },
                    { rx: 100, ry: 70, speed: -0.6 }
                ];

                orbitConfigs.forEach((config, index) => {
                    const orbitGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    orbitGroup.classList.add(`orbit-group-${index}`);
                    orbitGroup.setAttribute("data-rotation", "0");
                    orbitGroup.setAttribute("data-speed", config.speed);

                    const orbit = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
                    orbit.classList.add("orbit");
                    orbit.setAttribute("rx", config.rx);
                    orbit.setAttribute("ry", config.ry);
                    orbit.setAttribute("stroke", "black");
                    orbit.setAttribute("stroke-width", "1");
                    orbitGroup.appendChild(orbit);

                    for (let i = 0; i < particleCount; i++) {
                        const angle = (i * 360) / particleCount;
                        const x = config.rx * Math.cos(angle * Math.PI / 180);
                        const y = config.ry * Math.sin(angle * Math.PI / 180);
                        
                        const particle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        particle.classList.add("particle", "orbit-particle");
                        particle.setAttribute("r", "4");
                        particle.setAttribute("cx", x);
                        particle.setAttribute("cy", y);
                        particle.setAttribute("fill", "black");
                        particle.setAttribute("data-base-x", x);
                        particle.setAttribute("data-base-y", y);
                        orbitGroup.appendChild(particle);
                    }

                    orbitsGroup.appendChild(orbitGroup);
                });
            }

            async startRecording() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    
                    this.audioContext = new AudioContext();
                    this.analyser = this.audioContext.createAnalyser();
                    this.source = this.audioContext.createMediaStreamSource(stream);
                    
                    this.source.connect(this.analyser);
                    this.analyser.fftSize = 2048;
                    
                    this.mediaRecorder = new MediaRecorder(stream);
                    this.mediaRecorder.start();
                    
                    this.isRecording = true;
                    this.startTime = Date.now();
                    this.startBtn.disabled = true;
                    this.stopBtn.disabled = false;
                    
                    this.updateVisualization();
                } catch (err) {
                    console.error('Error accessing microphone:', err);
                }
            }

            stopRecording() {
                if (this.mediaRecorder?.state === 'recording') {
                    this.mediaRecorder.stop();
                }
                if (this.source) {
                    this.source.disconnect();
                }
                this.isRecording = false;
                this.startBtn.disabled = false;
                this.stopBtn.disabled = true;
                cancelAnimationFrame(this.animationFrameId);
            }

            updateColor() {
                const elapsed = (Date.now() - this.startTime) / 1000;
                const hue = (elapsed * 20) % 360;
                this.currentColor = `hsl(${hue}, 70%, 50%)`;
                
                document.querySelectorAll('.orbit, .particle, .rays line, .volume-ring')
                    .forEach(el => {
                        if (el.classList.contains('orbit') || el.classList.contains('volume-ring')) {
                            el.style.stroke = this.currentColor;
                        } else {
                            el.style.fill = this.currentColor;
                            if (el.tagName === 'line') {
                                el.style.stroke = this.currentColor;
                            }
                        }
                    });
            }

            getFrequencyRange(dataArray) {
                const sum = dataArray.reduce((a, b) => a + b, 0);
                return Math.floor(this.map(sum, 0, dataArray.length * 255, 2, 6));
            }

            map(value, inMin, inMax, outMin, outMax) {
                return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
            }

            updateVisualization() {
                if (!this.isRecording) return;
                
                this.animationFrameId = requestAnimationFrame(() => this.updateVisualization());
                
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                this.analyser.getByteFrequencyData(dataArray);
                
                const volume = dataArray.reduce((a, b) => a + b, 0) / bufferLength / 255;
                const particleCount = this.getFrequencyRange(dataArray);
                
                this.updateColor();
                
                // 更新音量環
                const volumeRing = document.querySelector('.volume-ring');
                volumeRing.style.strokeWidth = 1 + volume * 30;
                
                // 更新中心圓點
                const centerParticle = document.querySelector('.center-particle');
                centerParticle.setAttribute('r', 4 + volume * 6);
                
                // 更新放射線
                this.rayRotation += 0.5 + volume * 2;
                const rays = document.querySelectorAll('.rays line');
                const time = Date.now() / 1000;

                rays.forEach((ray, index) => {
                    const amplitude = this.rayAmplitudes[index];
                    const phase = this.rayPhases[index];
                    
                    const waveOffset = Math.sin(time * 2 + phase) * amplitude;
                    const lengthMultiplier = 1 + volume * 2 + waveOffset * 0.5;
                    
                    ray.setAttribute("y2", -40 * lengthMultiplier);
                    const strokeWidth = 1 + volume * 8 + Math.abs(waveOffset) * 2;
                    ray.style.strokeWidth = strokeWidth;
                    
                    const baseAngle = (index * 360) / rays.length;
                    const rotationAngle = baseAngle + this.rayRotation + Math.sin(time + phase) * 5;
                    ray.setAttribute("transform", `rotate(${rotationAngle})`);
                });

                // 更新軌道粗細
                document.querySelectorAll('.orbit').forEach((orbit, index) => {
                    const strokeWidth = 1 + volume * 8 * (1 - index * 0.2);
                    orbit.style.strokeWidth = strokeWidth;
                });

                // 更新軌道粒子
                document.querySelectorAll('.orbit-particle').forEach(particle => {
                    const baseX = parseFloat(particle.getAttribute('data-base-x') || 0);
                    const baseY = parseFloat(particle.getAttribute('data-base-y') || 0);
                    
                    const expansion = 1 + volume * 0.8;
                    particle.setAttribute('cx', baseX * expansion);
                    particle.setAttribute('cy', baseY * expansion);
                    particle.setAttribute('r', 4 + volume * 6);
                });

                // 更新軌道旋轉
                document.querySelectorAll('[class^="orbit-group-"]').forEach(group => {
                    const currentRotation = parseFloat(group.getAttribute('data-rotation'));
                    const speed = parseFloat(group.getAttribute('data-speed'));
                    const newRotation = (currentRotation + speed * (1 + volume)) % 360;
                    group.setAttribute('data-rotation', newRotation);
                    group.style.transform = `rotate(${newRotation}deg)`;
                });
            }
        }

        // 初始化視覺化效果
        new AudioVisualizer();
    </script>
</body>
</html>