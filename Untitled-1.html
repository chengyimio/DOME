<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spirit Audio Visualizer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background: linear-gradient(45deg, #1a1a1a, #2a2a2a);
            min-height: 100vh;
        }

        .visualization-container {
            aspect-ratio: 1;
            background: transparent;
        }

        svg {
            width: 100%;
            height: 100%;
            filter: blur(0.3px);
        }

        .audio-stats {
            color: white;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
        }

        .ray {
            stroke: rgba(255, 255, 255, 0.6);
            transition: all 0.3s ease;
        }

        .volume-ring {
            fill: none;
            stroke: rgba(255, 255, 255, 0.8);
            transition: all 0.3s ease;
        }

        .orbit {
            fill: none;
            stroke: rgba(255, 255, 255, 0.4);
            transition: all 0.3s ease;
        }

        .orbit-ball {
            fill: rgba(255, 255, 255, 0.8);
            transition: all 0.3s ease;
        }

        .custom-btn {
            background: transparent;
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container py-4">
        <div class="row">
            <div class="col-md-8">
                <div class="visualization-container">
                    <svg viewBox="-200 -200 400 400" preserveAspectRatio="xMidYMid meet">
                        <g class="visualization-group">
                            <!-- 中心放射線 -->
                            <g class="center-rays"></g>
                            <!-- 音量響應圓環 -->
                            <circle class="volume-ring" r="80" stroke-width="1"/>
                            <!-- 同心橢圓和運動小球 -->
                            <g class="orbits-group"></g>
                        </g>
                    </svg>
                </div>
                <div class="text-center">
                    <button id="startBtn" class="btn custom-btn me-2">開始錄音</button>
                    <button id="stopBtn" class="btn custom-btn" disabled>停止錄音</button>
                </div>
            </div>
            
            <div class="col-md-4">
                <div class="audio-stats">
                    <h4 class="mb-4">音頻分析</h4>
                    <div class="mb-3">
                        <label>分貝值 (dB)</label>
                        <div id="decibelValue" class="stat-value">0 dB</div>
                    </div>
                    <div class="mb-3">
                        <label>頻率</label>
                        <div id="frequencyValue" class="stat-value">0 Hz</div>
                    </div>
                    <div class="mb-3">
                        <label>音量</label>
                        <div id="volumeValue" class="stat-value">0%</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class AudioVisualizer {
            constructor() {
                this.initializeVariables();
                this.setupEventListeners();
                this.createVisualElements();
                this.startTime = null;
                this.colorHue = 0;
                this.minBalls = 3;    // 最少3顆球
                this.maxBalls = 10;   // 最多10顆球
                this.currentBalls = new Array(this.orbitCount).fill(this.minBalls); // 記錄每個軌道當前的球數
                this.frequencyRange = {
                    min: 85,  // 最低頻率
                    max: 255  // 最高頻率
        };
        

            }
                calculateBallCount(frequency) {
        return Math.round(
            this.map(
                frequency,
                this.frequencyRange.min,
                this.frequencyRange.max,
                this.minBalls,
                this.maxBalls
            )
        );
    }

            initializeVariables() {
                this.isRecording = false;
                this.animationFrameId = null;
                this.audioContext = null;
                this.analyser = null;
                this.mediaRecorder = null;

                // 視覺元素配置
                this.rayCount = 48;            // 放射線數量
                this.orbitCount = 3;           // 軌道數量
                this.ballsPerOrbit = 4;        // 每個軌道上的小球數量
                
                // 動畫相關
                this.orbitsRotation = 0;
                this.ballsRotation = 0;

                // DOM元素
                this.startBtn = document.getElementById('startBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.decibelValue = document.getElementById('decibelValue');
                this.frequencyValue = document.getElementById('frequencyValue');
                this.volumeValue = document.getElementById('volumeValue');
            }

            setupEventListeners() {
                this.startBtn.addEventListener('click', () => this.startRecording());
                this.stopBtn.addEventListener('click', () => this.stopRecording());
            }

            createVisualElements() {
                this.createCenterRays();
                this.createOrbits();
            }

            createCenterRays() {
                const raysGroup = document.querySelector('.center-rays');
                raysGroup.innerHTML = '';
                
                for (let i = 0; i < this.rayCount; i++) {
                    const angle = (i * 360) / this.rayCount;
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.classList.add('ray');
                    line.setAttribute("x1", "0");
                    line.setAttribute("y1", "0");
                    line.setAttribute("x2", "0");
                    line.setAttribute("y2", "-40");
                    line.setAttribute("transform", `rotate(${angle})`);
                    line.setAttribute("stroke-width", "1");
                    raysGroup.appendChild(line);
                }
            }

            createOrbits() {
    const orbitsGroup = document.querySelector('.orbits-group');
    orbitsGroup.innerHTML = '';

    // 定義橢圓軌道的配置
    const orbitConfigs = [
        { rx: 160, ry: 100, rotation: 0 },    // 最外層橢圓
        { rx: 140, ry: 85, rotation: 60 },    // 中層橢圓
        { rx: 120, ry: 70, rotation: 120 }    // 內層橢圓
    ];

    orbitConfigs.forEach((config, i) => {
        const orbitGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        orbitGroup.classList.add('orbit-group');

        // 創建橢圓軌道
        const orbit = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
        orbit.classList.add('orbit');
        orbit.setAttribute("rx", config.rx);
        orbit.setAttribute("ry", config.ry);
        orbit.setAttribute("data-rotation", config.rotation);
        orbit.setAttribute("transform", `rotate(${config.rotation})`);
        orbitGroup.appendChild(orbit);

        // 在橢圓軌道上添加小球
        for (let j = 0; j < this.ballsPerOrbit; j++) {
            const ball = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            ball.classList.add('orbit-ball');
            ball.setAttribute("r", "4");
            
            // 計算初始位置角度
            const angle = (j * 360) / this.ballsPerOrbit;
            ball.setAttribute("data-angle", angle);
            
            // 初始位置計算
            const angleRad = angle * Math.PI / 180;
            const x = config.rx * Math.cos(angleRad);
            const y = config.ry * Math.sin(angleRad);
            
            // 應用初始旋轉
            const rotationRad = config.rotation * Math.PI / 180;
            const rotatedX = x * Math.cos(rotationRad) - y * Math.sin(rotationRad);
            const rotatedY = x * Math.sin(rotationRad) + y * Math.cos(rotationRad);
            
            ball.setAttribute("cx", rotatedX);
            ball.setAttribute("cy", rotatedY);
            
            orbitGroup.appendChild(ball);
        }

        orbitsGroup.appendChild(orbitGroup);
    });
}

            async startRecording() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.startTime = Date.now();
                    this.colorHue = 0;
                    this.audioContext = new AudioContext();
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 2048;
                    
                    const source = this.audioContext.createMediaStreamSource(stream);
                    source.connect(this.analyser);
                    
                    this.mediaRecorder = new MediaRecorder(stream);
                    this.mediaRecorder.start();
                    
                    this.isRecording = true;
                    this.startBtn.disabled = true;
                    this.stopBtn.disabled = false;
                    
                    this.updateVisualization();
                } catch (err) {
                    console.error('Error accessing microphone:', err);
                }
            }

            stopRecording() {
                if (this.mediaRecorder?.state === 'recording') {
                    this.mediaRecorder.stop();
                }
                if (this.audioContext) {
                    this.audioContext.close();
                }
                this.isRecording = false;
                this.startBtn.disabled = false;
                this.stopBtn.disabled = true;
                cancelAnimationFrame(this.animationFrameId);
            }

            getAudioData() {
    if (!this.analyser) return null;

        const bufferLength = this.analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        this.analyser.getByteFrequencyData(dataArray);

        // 計算分貝值 (一般人說話的分貝範圍在 30-60 dB)
        const sum = dataArray.reduce((a, b) => a + b, 0);
        const average = sum / dataArray.length;
        const decibels = 20 * Math.log10(average / 255);
        
        // 將分貝值映射到正規化的音量值 (0-1)
        // 假設正常說話的範圍是 30-60 dB
        const normalizedVolume = this.map(decibels, -40, 0, 0, 1);
        const volume = Math.max(0, Math.min(1, normalizedVolume));

        // 在人聲頻率範圍內尋找主頻率（85Hz-255Hz）
        const minFreqBin = Math.floor(85 * this.analyser.fftSize / this.audioContext.sampleRate);
        const maxFreqBin = Math.floor(255 * this.analyser.fftSize / this.audioContext.sampleRate);
        
        let maxValue = 0;
        let maxIndex = 0;
        for (let i = minFreqBin; i <= maxFreqBin; i++) {
            if (dataArray[i] > maxValue) {
                maxValue = dataArray[i];
                maxIndex = i;
            }
        }
        const dominantFrequency = maxIndex * this.audioContext.sampleRate / this.analyser.fftSize;

        return {
            volume,
            decibels,
            frequency: dominantFrequency
        };
    }

    // 添加映射函數
    map(value, inMin, inMax, outMin, outMax) {
        return ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
    }



updateVisualization() {
        if (!this.isRecording) return;
        
        this.animationFrameId = requestAnimationFrame(() => this.updateVisualization());
        
        const audioData = this.getAudioData();
        if (!audioData) return;

        // 計算經過的時間和顏色
        const elapsed = (Date.now() - this.startTime) / 1000;
        this.colorHue = (elapsed * 15) % 360; // 每15秒完成一個顏色循環
        const currentColor = `hsl(${this.colorHue}, 70%, 60%)`;

        // 更新數據顯示
        this.decibelValue.textContent = `${audioData.decibels.toFixed(1)} dB`;
        this.frequencyValue.textContent = `${audioData.frequency.toFixed(0)} Hz`;
        this.volumeValue.textContent = `${(audioData.volume * 100).toFixed(1)}%`;

        // 更新放射線
        document.querySelectorAll('.ray').forEach((ray, i) => {
            const length = 40 + audioData.volume * 80;
            const opacity = 0.3 + audioData.volume * 0.7;
            ray.setAttribute("y2", -length);
            ray.style.stroke = currentColor;
            ray.style.strokeOpacity = opacity;
        });

        // 更新音量圓環
        const volumeRing = document.querySelector('.volume-ring');
        const ringWidth = 1 + audioData.volume * 20;
        volumeRing.style.stroke = currentColor;
        volumeRing.style.strokeWidth = ringWidth;
        volumeRing.style.strokeOpacity = 0.4 + audioData.volume * 0.6;

        // 更新軌道和小球
        const orbitGroups = document.querySelectorAll('.orbit-group');
        this.orbitsRotation += 0.2 * (1 + audioData.volume);
        this.ballsRotation += 0.5 * (1 + audioData.volume);

        orbitGroups.forEach((group, i) => {
            const orbit = group.querySelector('.orbit');
            const baseRx = parseFloat(orbit.getAttribute('rx'));
            const baseRy = parseFloat(orbit.getAttribute('ry'));
            const baseRotation = parseFloat(orbit.getAttribute('data-rotation') || '0');
            
            const orbitRotation = baseRotation + this.orbitsRotation * (i % 2 ? -1 : 1);
            
            orbit.setAttribute('transform', `rotate(${orbitRotation})`);
            orbit.style.stroke = currentColor;
            orbit.style.strokeOpacity = 0.2 + audioData.volume * 0.6;
            orbit.style.strokeWidth = 1 + audioData.volume * 3;

            // 更新小球
            const balls = group.querySelectorAll('.orbit-ball');
            balls.forEach((ball) => {
                const baseAngle = parseFloat(ball.getAttribute('data-angle'));
                const currentAngle = baseAngle + this.ballsRotation;
                
                const rx = baseRx * (1 + audioData.volume * 0.2);
                const ry = baseRy * (1 + audioData.volume * 0.2);
                
                const angleRad = currentAngle * Math.PI / 180;
                const x = rx * Math.cos(angleRad);
                const y = ry * Math.sin(angleRad);
                
                const rotationRad = orbitRotation * Math.PI / 180;
                const rotatedX = x * Math.cos(rotationRad) - y * Math.sin(rotationRad);
                const rotatedY = x * Math.sin(rotationRad) + y * Math.cos(rotationRad);
                
                ball.setAttribute("cx", rotatedX);
                ball.setAttribute("cy", rotatedY);
                
                ball.style.fill = currentColor;
                ball.setAttribute("r", 3 + audioData.volume * 8);
                ball.style.fillOpacity = 0.4 + audioData.volume * 0.6;
            });
        });
    }
}
     

        // 初始化視覺化效果
        new AudioVisualizer();
    </script>
</body>
</html>