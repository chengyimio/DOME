<!DOCTYPE html>
<html>
<head>
    <style>
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 20px;
        }
        
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        
        button:disabled {
            background-color: #cccccc;
        }
        
        canvas {
            border: 1px solid #ddd;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="visualizer" width="400" height="400"></canvas>
        <button id="startBtn">開始錄音</button>
        <button id="stopBtn" disabled>停止錄音</button>
    </div>

    <script>
        let audioContext;
        let analyser;
        let source;
        let mediaRecorder;
        let isRecording = false;
        
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = Math.min(centerX, centerY) - 50;
        
        startBtn.addEventListener('click', startRecording);
        stopBtn.addEventListener('click', stopRecording);
        
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                audioContext = new AudioContext();
                analyser = audioContext.createAnalyser();
                source = audioContext.createMediaStreamSource(stream);
                
                source.connect(analyser);
                analyser.fftSize = 256;
                
                mediaRecorder = new MediaRecorder(stream);
                mediaRecorder.start();
                
                isRecording = true;
                startBtn.disabled = true;
                stopBtn.disabled = false;
                
                draw();
            } catch (err) {
                console.error('Error accessing microphone:', err);
            }
        }
        
        function stopRecording() {
            mediaRecorder.stop();
            source.disconnect();
            isRecording = false;
            startBtn.disabled = false;
            stopBtn.disabled = true;
        }
        
        function draw() {
            if (!isRecording) return;
            
            requestAnimationFrame(draw);
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 繪製內圈放射線
            ctx.beginPath();
            for (let i = 0; i < 60; i++) {
                const angle = (i / 60) * Math.PI * 2;
                const innerRadius = radius * 0.4;
                const outerRadius = radius * 0.5;
                
                ctx.moveTo(
                    centerX + Math.cos(angle) * innerRadius,
                    centerY + Math.sin(angle) * innerRadius
                );
                ctx.lineTo(
                    centerX + Math.cos(angle) * outerRadius,
                    centerY + Math.sin(angle) * outerRadius
                );
            }
            ctx.strokeStyle = '#666';
            ctx.stroke();
            
            // 繪製中間圓環
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.6, 0, Math.PI * 2);
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // 繪製外圈頻譜
            ctx.beginPath();
            for (let i = 0; i < bufferLength; i++) {
                const angle = (i / bufferLength) * Math.PI * 2;
                const value = dataArray[i];
                const height = (value / 255) * (radius * 0.3);
                
                const x1 = centerX + Math.cos(angle) * (radius * 0.7);
                const y1 = centerY + Math.sin(angle) * (radius * 0.7);
                const x2 = centerX + Math.cos(angle) * (radius * 0.7 + height);
                const y2 = centerY + Math.sin(angle) * (radius * 0.7 + height);
                
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
            }
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    </script>
</body>
</html>